import prisma from "@/lib/prisma";
import { Prisma } from "@/generated/prisma";
import { MarketingAgent, CampaignMetrics, CampaignType } from "./agent";

// ---------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------

export type CampaignStatus =
  | "DRAFT"
  | "SCHEDULED"
  | "ACTIVE"
  | "PAUSED"
  | "COMPLETED";

export interface CampaignSchedule {
  /** ISO-8601 datetime string for when the campaign should start sending. */
  startAt: string;
  /** Optional ISO-8601 datetime string for when the campaign should stop. */
  endAt?: string;
  /** For drip campaigns: interval in hours between sequence emails. */
  intervalHours?: number;
  /** Timezone for scheduling (e.g. "America/New_York"). */
  timezone?: string;
}

export interface CampaignContent {
  subject?: string;
  headline?: string;
  body?: string;
  cta?: string;
  emailSequence?: Array<{
    day: number;
    subject: string;
    body: string;
    purpose: string;
  }>;
  [key: string]: unknown;
}

// ---------------------------------------------------------------------------
// CampaignManager
// ---------------------------------------------------------------------------

export class CampaignManager {
  private agent: MarketingAgent;

  constructor() {
    this.agent = new MarketingAgent();
  }

  // -------------------------------------------------------------------------
  // createCampaign
  // -------------------------------------------------------------------------

  /**
   * Create a new campaign in the database. The campaign starts in DRAFT
   * status. Content is auto-generated by the AI marketing agent based on the
   * campaign type and target audience description.
   */
  async createCampaign(
    name: string,
    type: CampaignType,
    targetAudience: string
  ) {
    try {
      // Use the AI agent to generate initial campaign content
      const generatedContent = await this.agent.generateCampaignContent(
        type,
        targetAudience
      );

      const campaign = await prisma.campaign.create({
        data: {
          name,
          type,
          status: "DRAFT",
          content: generatedContent as unknown as Prisma.InputJsonValue,
          metrics: {
            totalContacts: 0,
            sent: 0,
            opened: 0,
            clicked: 0,
            replied: 0,
          } as unknown as Prisma.InputJsonValue,
        },
      });

      console.info(
        `[CampaignManager] Created campaign "${name}" (${campaign.id})`
      );
      return campaign;
    } catch (error) {
      const message =
        error instanceof Error ? error.message : "Unknown error";
      throw new Error(`Failed to create campaign "${name}": ${message}`);
    }
  }

  // -------------------------------------------------------------------------
  // scheduleCampaign
  // -------------------------------------------------------------------------

  /**
   * Attach a schedule to a campaign and move it to SCHEDULED status. The
   * campaign must be in DRAFT status to be scheduled.
   */
  async scheduleCampaign(campaignId: string, schedule: CampaignSchedule) {
    const campaign = await prisma.campaign.findUnique({
      where: { id: campaignId },
    });

    if (!campaign) {
      throw new Error(`Campaign ${campaignId} not found`);
    }

    if (campaign.status !== "DRAFT" && campaign.status !== "PAUSED") {
      throw new Error(
        `Campaign ${campaignId} cannot be scheduled from status "${campaign.status}". ` +
          `Only DRAFT or PAUSED campaigns can be scheduled.`
      );
    }

    const startAt = new Date(schedule.startAt);
    if (isNaN(startAt.getTime())) {
      throw new Error(`Invalid startAt date: ${schedule.startAt}`);
    }

    if (schedule.endAt) {
      const endAt = new Date(schedule.endAt);
      if (isNaN(endAt.getTime()) || endAt <= startAt) {
        throw new Error(
          `Invalid endAt date: must be a valid date after startAt`
        );
      }
    }

    const updated = await prisma.campaign.update({
      where: { id: campaignId },
      data: {
        status: "SCHEDULED",
        schedule: schedule as unknown as Prisma.InputJsonValue,
      },
    });

    console.info(
      `[CampaignManager] Scheduled campaign "${updated.name}" for ${schedule.startAt}`
    );
    return updated;
  }

  // -------------------------------------------------------------------------
  // executeCampaign
  // -------------------------------------------------------------------------

  /**
   * Execute a campaign: set it to ACTIVE and send personalized outreach to
   * every contact attached to the campaign that has not yet been sent.
   */
  async executeCampaign(campaignId: string) {
    const campaign = await prisma.campaign.findUnique({
      where: { id: campaignId },
      include: {
        contacts: {
          where: { sentAt: null },
          include: { lead: true },
        },
      },
    });

    if (!campaign) {
      throw new Error(`Campaign ${campaignId} not found`);
    }

    if (campaign.status !== "SCHEDULED" && campaign.status !== "ACTIVE") {
      throw new Error(
        `Campaign ${campaignId} cannot be executed from status "${campaign.status}". ` +
          `Only SCHEDULED or ACTIVE campaigns can be executed.`
      );
    }

    // Move to ACTIVE
    await prisma.campaign.update({
      where: { id: campaignId },
      data: { status: "ACTIVE" },
    });

    const results: Array<{ contactId: string; success: boolean; error?: string }> = [];

    for (const contact of campaign.contacts) {
      try {
        // Generate personalized outreach using the AI agent
        const outreach = await this.agent.generatePersonalizedOutreach(
          {
            id: contact.lead.id,
            email: contact.lead.email,
            name: contact.lead.name,
            source: contact.lead.source,
            status: contact.lead.status,
            score: contact.lead.score,
            notes: contact.lead.notes,
            lastContact: contact.lead.lastContact,
            createdAt: contact.lead.createdAt,
          },
          {
            id: campaign.id,
            name: campaign.name,
            type: campaign.type,
            content: campaign.content as Record<string, unknown>,
          }
        );

        // In a production system, this is where you would integrate with an
        // email sending service (SendGrid, Resend, SES, etc.). For now we
        // mark the contact as sent and store the generated outreach.
        console.info(
          `[CampaignManager] Generated outreach for ${contact.lead.email}: "${outreach.subject}"`
        );

        await prisma.campaignContact.update({
          where: { id: contact.id },
          data: { sentAt: new Date() },
        });

        // Update lead's last contact date
        await prisma.lead.update({
          where: { id: contact.leadId },
          data: { lastContact: new Date() },
        });

        results.push({ contactId: contact.id, success: true });
      } catch (error) {
        const message =
          error instanceof Error ? error.message : "Unknown error";
        console.error(
          `[CampaignManager] Failed to send to ${contact.lead.email}: ${message}`
        );
        results.push({ contactId: contact.id, success: false, error: message });
      }
    }

    // If all contacts have been sent, mark campaign as completed
    const remainingUnsent = await prisma.campaignContact.count({
      where: { campaignId, sentAt: null },
    });

    if (remainingUnsent === 0) {
      await prisma.campaign.update({
        where: { id: campaignId },
        data: { status: "COMPLETED" },
      });
      console.info(
        `[CampaignManager] Campaign "${campaign.name}" completed -- all contacts reached.`
      );
    }

    const successCount = results.filter((r) => r.success).length;
    console.info(
      `[CampaignManager] Executed campaign "${campaign.name}": ` +
        `${successCount}/${results.length} contacts sent successfully.`
    );

    return { campaignId, results, remainingUnsent };
  }

  // -------------------------------------------------------------------------
  // pauseCampaign / resumeCampaign
  // -------------------------------------------------------------------------

  /**
   * Pause an active campaign. No further sends will occur until resumed.
   */
  async pauseCampaign(campaignId: string) {
    const campaign = await prisma.campaign.findUnique({
      where: { id: campaignId },
    });

    if (!campaign) {
      throw new Error(`Campaign ${campaignId} not found`);
    }

    if (campaign.status !== "ACTIVE" && campaign.status !== "SCHEDULED") {
      throw new Error(
        `Campaign ${campaignId} cannot be paused from status "${campaign.status}". ` +
          `Only ACTIVE or SCHEDULED campaigns can be paused.`
      );
    }

    const updated = await prisma.campaign.update({
      where: { id: campaignId },
      data: { status: "PAUSED" },
    });

    console.info(`[CampaignManager] Paused campaign "${updated.name}"`);
    return updated;
  }

  /**
   * Resume a paused campaign. Sets it back to SCHEDULED so the scheduler
   * can pick it up on its next run.
   */
  async resumeCampaign(campaignId: string) {
    const campaign = await prisma.campaign.findUnique({
      where: { id: campaignId },
    });

    if (!campaign) {
      throw new Error(`Campaign ${campaignId} not found`);
    }

    if (campaign.status !== "PAUSED") {
      throw new Error(
        `Campaign ${campaignId} cannot be resumed from status "${campaign.status}". ` +
          `Only PAUSED campaigns can be resumed.`
      );
    }

    const updated = await prisma.campaign.update({
      where: { id: campaignId },
      data: { status: "SCHEDULED" },
    });

    console.info(`[CampaignManager] Resumed campaign "${updated.name}"`);
    return updated;
  }

  // -------------------------------------------------------------------------
  // getCampaignMetrics
  // -------------------------------------------------------------------------

  /**
   * Compute and return engagement metrics for a campaign. Also runs the AI
   * agent's metric analysis to produce optimization suggestions.
   */
  async getCampaignMetrics(campaignId: string) {
    const campaign = await prisma.campaign.findUnique({
      where: { id: campaignId },
      include: { contacts: true },
    });

    if (!campaign) {
      throw new Error(`Campaign ${campaignId} not found`);
    }

    const totalContacts = campaign.contacts.length;
    const sent = campaign.contacts.filter((c) => c.sentAt !== null).length;
    const opened = campaign.contacts.filter((c) => c.openedAt !== null).length;
    const clicked = campaign.contacts.filter((c) => c.clickedAt !== null).length;
    const replied = campaign.contacts.filter((c) => c.repliedAt !== null).length;

    const metrics: CampaignMetrics = {
      campaignId: campaign.id,
      campaignName: campaign.name,
      type: campaign.type,
      totalContacts,
      sent,
      opened,
      clicked,
      replied,
      openRate: sent > 0 ? opened / sent : 0,
      clickRate: sent > 0 ? clicked / sent : 0,
      replyRate: sent > 0 ? replied / sent : 0,
    };

    // Store computed metrics snapshot on the campaign
    await prisma.campaign.update({
      where: { id: campaignId },
      data: { metrics: metrics as unknown as Prisma.InputJsonValue },
    });

    // Run AI analysis if we have meaningful data
    let analysis = null;
    if (sent >= 10) {
      try {
        analysis = await this.agent.analyzeMetrics(metrics);
      } catch (error) {
        console.warn(
          `[CampaignManager] AI metrics analysis failed: ${
            error instanceof Error ? error.message : "Unknown error"
          }`
        );
      }
    }

    return { metrics, analysis };
  }

  // -------------------------------------------------------------------------
  // addLeadsToCampaign
  // -------------------------------------------------------------------------

  /**
   * Associate a set of leads with a campaign. Creates CampaignContact
   * junction records. Duplicate lead-campaign pairs are silently skipped.
   */
  async addLeadsToCampaign(campaignId: string, leadIds: string[]) {
    const campaign = await prisma.campaign.findUnique({
      where: { id: campaignId },
    });

    if (!campaign) {
      throw new Error(`Campaign ${campaignId} not found`);
    }

    if (campaign.status === "COMPLETED") {
      throw new Error(
        `Cannot add leads to a completed campaign (${campaignId}).`
      );
    }

    // Verify all leads exist
    const existingLeads = await prisma.lead.findMany({
      where: { id: { in: leadIds } },
      select: { id: true },
    });
    const existingLeadIds = new Set(existingLeads.map((l) => l.id));

    const missingIds = leadIds.filter((id) => !existingLeadIds.has(id));
    if (missingIds.length > 0) {
      console.warn(
        `[CampaignManager] Skipping ${missingIds.length} unknown lead IDs: ${missingIds.join(", ")}`
      );
    }

    // Filter to only valid leads and create contacts, skipping duplicates
    const validLeadIds = leadIds.filter((id) => existingLeadIds.has(id));

    let addedCount = 0;
    let skippedCount = 0;

    for (const leadId of validLeadIds) {
      try {
        await prisma.campaignContact.create({
          data: {
            campaignId,
            leadId,
          },
        });
        addedCount++;
      } catch (error) {
        // Unique constraint violation means this lead is already in the campaign
        if (
          error instanceof Error &&
          error.message.includes("Unique constraint")
        ) {
          skippedCount++;
        } else {
          throw error;
        }
      }
    }

    console.info(
      `[CampaignManager] Added ${addedCount} leads to campaign "${campaign.name}" ` +
        `(${skippedCount} duplicates skipped, ${missingIds.length} not found)`
    );

    return { campaignId, added: addedCount, skipped: skippedCount, notFound: missingIds.length };
  }
}
